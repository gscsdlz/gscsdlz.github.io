# ZIPLIST

> 根据注释机翻加补充

> ziplist是经过特殊编码的双向链表，其设计目的是使其具有较高的内存效率。 它存储字符串和整数值，其中整数被编码为实际整数，而不是一串字符。 它允许在列表的两侧进行pop和push操作，时间复杂度为O(1)，但是由于每个操作都需要重新分配ziplist使用的内存，实际复杂度与ziplist使用的内存量有关。

## 总体布局

> 如果没有另外指定，所有字段都以小端序存储。

```html
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```

&lt;uint32_t zlbytes&gt;是一个无符号整数，用于保存整个ziplist占用的字节数（包括zlbytes字段本身的四个字节）。 存储该值是为了方便调整整个list的大小时无需先遍历它。

&lt;uint32_t zltail>是list中最后一个元素的偏移量。通过这个值，在list的另一端执行pop操作时无需完全遍历。

&lt;uint16_t zllen&gt;是元素个数。 当list中有超过2 ^ 16-2个元素时，zllen被设置为2 ^ 16-1，这时我们需要遍历整个list才能知道它包含多少元素。

&lt;uint8_t zlend&gt;是代表ziplist末尾的特殊元素，只有一个字节编码为255(0xff)。其他的普通元素不会以0xff的字节开始。

## 元素布局

ziplist中的每个元素都以包含有两个信息的元数据作为前缀。 首先，存储前一个元素的长度以便能够从后到前遍历list； 第二，提供元素的编码结构它表示元素的类型（整数或字符串），对于字符串它还表示字符串有效的长度。 因此，完整的元素存储方式如下：

```html
<prevlen> <encoding> <entry-data>
```

有时编码代表元素本身，就像小整数一样，我们将在后面看到。 在这种情况下，&lt;entry-data&gt;部分丢失了，我们可以这样：

```html
<prevlen> <encoding>
```

上一个条目的长度&lt;prevlen&gt;编码方式如下：

如果该元素长度小于254个字节，则它将仅消耗一个字节来表示该长度，这是一个8位的无符号整数。

当长度大于或等于254时，它将占用5个字节。 第一个字节设置为254（0xFE），以指示随后的较大值，其余4个字节表示前一个元素的长度。

因此，实际上元素是通过以下方式编码的：

```html
<prevlen from 0 to 253> <encoding> <entry>
```

或者如果先前的元素长度大于253个字节，则使用以下方式编码：

```html
0xFE <4 bytes unsigned little endian prevlen> <encoding> <entry>
```

元素的编码字段取决于元素的内容。 当元素是字符串时，&lt;encoding&gt;的第一个字节的前2位代表字符串的长度类型，然后是这个字符串的实际长度。 当元素是整数时，前2位都设置为1，接下来的2位代表整数的类型。 不同类型和编码的概述如下（所有元素都可以通过第一个字节确定其类型）：

- |00pppppp| - 1 byte
    - 长度小于或等于63个字节（6位）的字符串值。”pppppp“表示字符串实际长度（6位无符号整数）。
- |01pppppp|qqqqqqqq| - 2 bytes
    - 长度小于或等于16383个字节（14位，小于16KB）的字符串值 `注意：此长度值按大端序存储`
- |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
    - 长度大等于16384个字节的字符串值。仅使用第1个字节之后的4个字节表示长度，最大为2 ^ 32 - 1（4GB），第一个字节的低6位未使用且设置为零。
- |11000000| - 3 bytes
    - 占用两个字节的整数 int16
- |11010000| - 5 bytes
    - 占用4个字节的整数 int32
- |11100000| - 9 bytes
    - 占用8个字节的整数 int64
- |11110000| - 4 bytes
    - 占用3个字节的整数
- |11111110| - 2 bytes
    - 占用1个字节的整数 int8
- |1111xxxx| - 1 bytes
    - 4bit的立即数（xxxx在0000 - 1101），表示从0到12的一个无符号数。但是实际上存储的是1-13，因为0000和1111不能用，所以使用时需要将存储的值减1来得到真实的数据

## 示例

以下示例是一个包含2个字符串（”2“， ”5”）的ziplist，一共占用了15个字节，我们在效果上把它们的分开

```
[0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]
      |             |          |       |       |     |
   zlbytes        zltail    entries   "2"     "5"   end
```

最开始的4个字节（小端序 应该这么看 0x0000000f )代表15，即整个ziplist占用的字节数

紧接着的4个字节是最后一个元素的偏移量即12（0x0000000c)，可以看出最后一个元素"5"确实就是在第12个字节处

接下来的2个字节表示的是整个ziplist的元素个数，它的值是2（0x0002)因为现在ziplist里面有2个元素

最后 “00 f3”是ziplist中存储的第一个元素“2”，每个元素由两部分组成（前一个元素的长度和存储的数据），因为这是list中的第一个是元素，所以在这里上一个元素的长度是0，紧接着0xf3表示的元素类型是1111xxxx(即0-12之间的小整数)，所以先把高4位的0xf移除然后减1，即0x3 - 1等于2

下一个元素基本类似，首先prevlen等于2，因为list中的第一个元素正好占用2个字节，接着是0xF6规则和0xF3类似，所以是6-1=5，因此这个元素的值是5

最后特殊的0xff表示list结束

在上面的ziplist中添加一个字符串"Hello World"，我们可以看看ziplist是怎么存储比较小的字符串的，我们将下面示例的16进制添加到上面的ziplist中

```
[02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64]
```

第一个字节0x02是上一个元素的长度，紧接着的0x0b代表整个元素的编码方式，它对应的上面提到的|00pppppp|(不超过63字节的字符串)，其中的pppppp部分表示字符串的实际长度，所以0x0B意思是字符串的长度是11。从第三个字节(0x48)开始到最后一个字节（0x64)，它们都是"Hello World"这个字符串的ASCII字符
