# 41.缺失的第一个正数

<span style="color:#d9534f">困难</span>

## 题目含义
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

例如[2,3,4],返回1

需要O(n)的时间复杂度且不要开辟多余的内存空间

## 解法
假设数组中不包括1，那么这道题未出现的正整数n的前后区间一定在[2,n-1], [n+1,+∞]，我们需要去标记这两个区间的数字有没有出现过。

由于数组的长度是一定的，那么缺失的正数肯定不会大于n+1，例如[1,2,3,4]，缺失的正数为5

- 检查1，如果数组中没有1，直接返回1
- 清洗数据，将负数、0和超过数组长度的全部改为1

这样将两个区间转换为了去标记[1,n-1]有没有出现过，如果可以开辟一个等大小的数组，那么可以遍历一遍原数组，在新数组中记录下，重新遍历新数组就可以知道谁没有出现，特别的将等于数组长度的数字写到0上，避免溢出。

```
3 4 -1 1
重写
3 4 1 1

开辟新数组
0 0 0 0
记录出现
1 1 0 1

返回2
```

但是题目要求不要开辟额外的空间，那么我们可以将原数组做一个操作，我们可以用正负数来表示出现情况，负数表示出现，反之。那么上述的数组会变为

```
3 4 -1 1
重写
3 4 1 1

改写
-3 -4 1 -1

第一个正数的下标为2，所以结果为2
```

特别的，如果从1开始遍历完以后，没有发现任何正数，那么可能有两种情况

- [1,2,3] => [-1, -2, -3] 首位为负数，说明数组中【1，n】都被使用了，输出n+1即4
- [1,2,4] => [1,2,1] => [1, -2, -1] 首位为正数，说明和数组长度一样的数字没有出现，输出n即3


## 代码

| 算法 | 执行用时 | 内存消耗MB |
| ---- | -------- | ---------  |
| -   | 0ms | 2.2MB |

<hr/>

```go
func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}

func firstMissingPositive(nums []int) int {
	hasOne := false
	for _, v := range nums {
		if v == 1 {
			hasOne = true
			break
		}
	}
	if !hasOne {
		return 1
	}
	//有1长度为1，那么nums就是[1]
	if len(nums) == 1 {
		return 2
	}
	for k, v := range nums {
		//负数或者超过n的不考虑，结果肯定在1 ---- n 之间
		if v <= 0 || v > len(nums) {
			nums[k] = 1
		}
	}


	for _, v := range nums {
		k := abs(v)
		if len(nums) == k {
			nums[0] = -abs(nums[0])
		} else {
			nums[k] = -abs(nums[k])
		}
	}

	for i := 1; i < len(nums); i++ {
		if nums[i] > 0 {
			return i
		}
	}
	if nums[0] > 0 {
		return len(nums)
	}
	return len(nums) + 1
}
```
